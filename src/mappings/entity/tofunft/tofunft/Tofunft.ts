// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class EvAuctionRefund extends ethereum.Event {
  get params(): EvAuctionRefund__Params {
    return new EvAuctionRefund__Params(this);
  }
}

export class EvAuctionRefund__Params {
  _event: EvAuctionRefund;

  constructor(event: EvAuctionRefund) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get bidder(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get refund(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class EvCouponSpent extends ethereum.Event {
  get params(): EvCouponSpent__Params {
    return new EvCouponSpent__Params(this);
  }
}

export class EvCouponSpent__Params {
  _event: EvCouponSpent;

  constructor(event: EvCouponSpent) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get couponId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class EvInventoryUpdate extends ethereum.Event {
  get params(): EvInventoryUpdate__Params {
    return new EvInventoryUpdate__Params(this);
  }
}

export class EvInventoryUpdate__Params {
  _event: EvInventoryUpdate;

  constructor(event: EvInventoryUpdate) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get inventory(): EvInventoryUpdateInventoryStruct {
    return changetype<EvInventoryUpdateInventoryStruct>(
      this._event.parameters[1].value.toTuple()
    );
  }
}

export class EvInventoryUpdateInventoryStruct extends ethereum.Tuple {
  get seller(): Address {
    return this[0].toAddress();
  }

  get buyer(): Address {
    return this[1].toAddress();
  }

  get currency(): Address {
    return this[2].toAddress();
  }

  get price(): BigInt {
    return this[3].toBigInt();
  }

  get netPrice(): BigInt {
    return this[4].toBigInt();
  }

  get deadline(): BigInt {
    return this[5].toBigInt();
  }

  get kind(): i32 {
    return this[6].toI32();
  }

  get status(): i32 {
    return this[7].toI32();
  }
}

export class EvMarketSignerUpdate extends ethereum.Event {
  get params(): EvMarketSignerUpdate__Params {
    return new EvMarketSignerUpdate__Params(this);
  }
}

export class EvMarketSignerUpdate__Params {
  _event: EvMarketSignerUpdate;

  constructor(event: EvMarketSignerUpdate) {
    this._event = event;
  }

  get addr(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get isRemoval(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class EvSettingsUpdated extends ethereum.Event {
  get params(): EvSettingsUpdated__Params {
    return new EvSettingsUpdated__Params(this);
  }
}

export class EvSettingsUpdated__Params {
  _event: EvSettingsUpdated;

  constructor(event: EvSettingsUpdated) {
    this._event = event;
  }
}

export class EvSwapped extends ethereum.Event {
  get params(): EvSwapped__Params {
    return new EvSwapped__Params(this);
  }
}

export class EvSwapped__Params {
  _event: EvSwapped;

  constructor(event: EvSwapped) {
    this._event = event;
  }

  get req(): EvSwappedReqStruct {
    return changetype<EvSwappedReqStruct>(
      this._event.parameters[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get swapper(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class EvSwappedReqStruct extends ethereum.Tuple {
  get salt(): Bytes {
    return this[0].toBytes();
  }

  get creator(): Address {
    return this[1].toAddress();
  }

  get deadline(): BigInt {
    return this[2].toBigInt();
  }

  get has(): Array<EvSwappedReqHasStruct> {
    return this[3].toTupleArray<EvSwappedReqHasStruct>();
  }

  get wants(): Array<EvSwappedReqWantsStruct> {
    return this[4].toTupleArray<EvSwappedReqWantsStruct>();
  }
}

export class EvSwappedReqHasStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }
}

export class EvSwappedReqWantsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Tofunft__inventoriesResult {
  value0: Address;
  value1: Address;
  value2: Address;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: i32;
  value7: i32;

  constructor(
    value0: Address,
    value1: Address,
    value2: Address,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: i32,
    value7: i32
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set(
      "value6",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value6))
    );
    map.set(
      "value7",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value7))
    );
    return map;
  }

  getSeller(): Address {
    return this.value0;
  }

  getBuyer(): Address {
    return this.value1;
  }

  getCurrency(): Address {
    return this.value2;
  }

  getPrice(): BigInt {
    return this.value3;
  }

  getNetPrice(): BigInt {
    return this.value4;
  }

  getDeadline(): BigInt {
    return this.value5;
  }

  getKind(): i32 {
    return this.value6;
  }

  getStatus(): i32 {
    return this.value7;
  }
}

export class Tofunft__inventoryTokensResult {
  value0: Address;
  value1: BigInt;
  value2: BigInt;
  value3: i32;
  value4: Bytes;

  constructor(
    value0: Address,
    value1: BigInt,
    value2: BigInt,
    value3: i32,
    value4: Bytes
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set(
      "value3",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value3))
    );
    map.set("value4", ethereum.Value.fromBytes(this.value4));
    return map;
  }

  getToken(): Address {
    return this.value0;
  }

  getTokenId(): BigInt {
    return this.value1;
  }

  getAmount(): BigInt {
    return this.value2;
  }

  getKind(): i32 {
    return this.value3;
  }

  getMintData(): Bytes {
    return this.value4;
  }
}

export class Tofunft extends ethereum.SmartContract {
  static bind(address: Address): Tofunft {
    return new Tofunft("Tofunft", address);
  }

  KIND_AUCTION(): i32 {
    let result = super.call("KIND_AUCTION", "KIND_AUCTION():(uint8)", []);

    return result[0].toI32();
  }

  try_KIND_AUCTION(): ethereum.CallResult<i32> {
    let result = super.tryCall("KIND_AUCTION", "KIND_AUCTION():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  KIND_BUY(): i32 {
    let result = super.call("KIND_BUY", "KIND_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_KIND_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall("KIND_BUY", "KIND_BUY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  KIND_SELL(): i32 {
    let result = super.call("KIND_SELL", "KIND_SELL():(uint8)", []);

    return result[0].toI32();
  }

  try_KIND_SELL(): ethereum.CallResult<i32> {
    let result = super.tryCall("KIND_SELL", "KIND_SELL():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_ACCEPT_AUCTION(): i32 {
    let result = super.call(
      "OP_ACCEPT_AUCTION",
      "OP_ACCEPT_AUCTION():(uint8)",
      []
    );

    return result[0].toI32();
  }

  try_OP_ACCEPT_AUCTION(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "OP_ACCEPT_AUCTION",
      "OP_ACCEPT_AUCTION():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_ACCEPT_BUY(): i32 {
    let result = super.call("OP_ACCEPT_BUY", "OP_ACCEPT_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_ACCEPT_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_ACCEPT_BUY", "OP_ACCEPT_BUY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_BID(): i32 {
    let result = super.call("OP_BID", "OP_BID():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_BID(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_BID", "OP_BID():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_BUY(): i32 {
    let result = super.call("OP_BUY", "OP_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_BUY", "OP_BUY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_CANCEL_BUY(): i32 {
    let result = super.call("OP_CANCEL_BUY", "OP_CANCEL_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_CANCEL_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_CANCEL_BUY", "OP_CANCEL_BUY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_COMPLETE_AUCTION(): i32 {
    let result = super.call(
      "OP_COMPLETE_AUCTION",
      "OP_COMPLETE_AUCTION():(uint8)",
      []
    );

    return result[0].toI32();
  }

  try_OP_COMPLETE_AUCTION(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "OP_COMPLETE_AUCTION",
      "OP_COMPLETE_AUCTION():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_COMPLETE_BUY(): i32 {
    let result = super.call("OP_COMPLETE_BUY", "OP_COMPLETE_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_COMPLETE_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "OP_COMPLETE_BUY",
      "OP_COMPLETE_BUY():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_COMPLETE_SELL(): i32 {
    let result = super.call(
      "OP_COMPLETE_SELL",
      "OP_COMPLETE_SELL():(uint8)",
      []
    );

    return result[0].toI32();
  }

  try_OP_COMPLETE_SELL(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "OP_COMPLETE_SELL",
      "OP_COMPLETE_SELL():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_MAX(): i32 {
    let result = super.call("OP_MAX", "OP_MAX():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_MAX(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_MAX", "OP_MAX():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_MIN(): i32 {
    let result = super.call("OP_MIN", "OP_MIN():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_MIN(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_MIN", "OP_MIN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  OP_REJECT_BUY(): i32 {
    let result = super.call("OP_REJECT_BUY", "OP_REJECT_BUY():(uint8)", []);

    return result[0].toI32();
  }

  try_OP_REJECT_BUY(): ethereum.CallResult<i32> {
    let result = super.tryCall("OP_REJECT_BUY", "OP_REJECT_BUY():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  RATE_BASE(): BigInt {
    let result = super.call("RATE_BASE", "RATE_BASE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_RATE_BASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("RATE_BASE", "RATE_BASE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  STATUS_CANCELLED(): i32 {
    let result = super.call(
      "STATUS_CANCELLED",
      "STATUS_CANCELLED():(uint8)",
      []
    );

    return result[0].toI32();
  }

  try_STATUS_CANCELLED(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "STATUS_CANCELLED",
      "STATUS_CANCELLED():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  STATUS_DONE(): i32 {
    let result = super.call("STATUS_DONE", "STATUS_DONE():(uint8)", []);

    return result[0].toI32();
  }

  try_STATUS_DONE(): ethereum.CallResult<i32> {
    let result = super.tryCall("STATUS_DONE", "STATUS_DONE():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  STATUS_OPEN(): i32 {
    let result = super.call("STATUS_OPEN", "STATUS_OPEN():(uint8)", []);

    return result[0].toI32();
  }

  try_STATUS_OPEN(): ethereum.CallResult<i32> {
    let result = super.tryCall("STATUS_OPEN", "STATUS_OPEN():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  TOKEN_1155(): i32 {
    let result = super.call("TOKEN_1155", "TOKEN_1155():(uint8)", []);

    return result[0].toI32();
  }

  try_TOKEN_1155(): ethereum.CallResult<i32> {
    let result = super.tryCall("TOKEN_1155", "TOKEN_1155():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  TOKEN_721(): i32 {
    let result = super.call("TOKEN_721", "TOKEN_721():(uint8)", []);

    return result[0].toI32();
  }

  try_TOKEN_721(): ethereum.CallResult<i32> {
    let result = super.tryCall("TOKEN_721", "TOKEN_721():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  TOKEN_MINT(): i32 {
    let result = super.call("TOKEN_MINT", "TOKEN_MINT():(uint8)", []);

    return result[0].toI32();
  }

  try_TOKEN_MINT(): ethereum.CallResult<i32> {
    let result = super.tryCall("TOKEN_MINT", "TOKEN_MINT():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  couponSpent(param0: BigInt): boolean {
    let result = super.call("couponSpent", "couponSpent(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBoolean();
  }

  try_couponSpent(param0: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("couponSpent", "couponSpent(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasInv(id: BigInt): boolean {
    let result = super.call("hasInv", "hasInv(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_hasInv(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasInv", "hasInv(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasSignedIntention(op: i32): boolean {
    let result = super.call(
      "hasSignedIntention",
      "hasSignedIntention(uint8):(bool)",
      [ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(op))]
    );

    return result[0].toBoolean();
  }

  try_hasSignedIntention(op: i32): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasSignedIntention",
      "hasSignedIntention(uint8):(bool)",
      [ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(op))]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  inventories(param0: BigInt): Tofunft__inventoriesResult {
    let result = super.call(
      "inventories",
      "inventories(uint256):(address,address,address,uint256,uint256,uint256,uint8,uint8)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new Tofunft__inventoriesResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toAddress(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toI32(),
      result[7].toI32()
    );
  }

  try_inventories(
    param0: BigInt
  ): ethereum.CallResult<Tofunft__inventoriesResult> {
    let result = super.tryCall(
      "inventories",
      "inventories(uint256):(address,address,address,uint256,uint256,uint256,uint8,uint8)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Tofunft__inventoriesResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toAddress(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toI32(),
        value[7].toI32()
      )
    );
  }

  inventoryTokenCounts(param0: BigInt): BigInt {
    let result = super.call(
      "inventoryTokenCounts",
      "inventoryTokenCounts(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBigInt();
  }

  try_inventoryTokenCounts(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "inventoryTokenCounts",
      "inventoryTokenCounts(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  inventoryTokens(
    param0: BigInt,
    param1: BigInt
  ): Tofunft__inventoryTokensResult {
    let result = super.call(
      "inventoryTokens",
      "inventoryTokens(uint256,uint256):(address,uint256,uint256,uint8,bytes)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new Tofunft__inventoryTokensResult(
      result[0].toAddress(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toI32(),
      result[4].toBytes()
    );
  }

  try_inventoryTokens(
    param0: BigInt,
    param1: BigInt
  ): ethereum.CallResult<Tofunft__inventoryTokensResult> {
    let result = super.tryCall(
      "inventoryTokens",
      "inventoryTokens(uint256,uint256):(address,uint256,uint256,uint8,bytes)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Tofunft__inventoryTokensResult(
        value[0].toAddress(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toI32(),
        value[4].toBytes()
      )
    );
  }

  isAuction(id: BigInt): boolean {
    let result = super.call("isAuction", "isAuction(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isAuction(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAuction", "isAuction(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isAuctionOpen(id: BigInt): boolean {
    let result = super.call("isAuctionOpen", "isAuctionOpen(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isAuctionOpen(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAuctionOpen",
      "isAuctionOpen(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isBundleApproved(invId: BigInt, owner: Address): boolean {
    let result = super.call(
      "isBundleApproved",
      "isBundleApproved(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(invId),
        ethereum.Value.fromAddress(owner)
      ]
    );

    return result[0].toBoolean();
  }

  try_isBundleApproved(
    invId: BigInt,
    owner: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isBundleApproved",
      "isBundleApproved(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(invId),
        ethereum.Value.fromAddress(owner)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isBuy(id: BigInt): boolean {
    let result = super.call("isBuy", "isBuy(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isBuy(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isBuy", "isBuy(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isBuyOpen(id: BigInt): boolean {
    let result = super.call("isBuyOpen", "isBuyOpen(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isBuyOpen(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isBuyOpen", "isBuyOpen(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isExpired(id: BigInt): boolean {
    let result = super.call("isExpired", "isExpired(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isExpired(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isExpired", "isExpired(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSell(id: BigInt): boolean {
    let result = super.call("isSell", "isSell(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isSell(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isSell", "isSell(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSignatureValid(signature: Bytes, hash: Bytes, signer: Address): boolean {
    let result = super.call(
      "isSignatureValid",
      "isSignatureValid(bytes,bytes32,address):(bool)",
      [
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromAddress(signer)
      ]
    );

    return result[0].toBoolean();
  }

  try_isSignatureValid(
    signature: Bytes,
    hash: Bytes,
    signer: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSignatureValid",
      "isSignatureValid(bytes,bytes32,address):(bool)",
      [
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromAddress(signer)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isStatusOpen(id: BigInt): boolean {
    let result = super.call("isStatusOpen", "isStatusOpen(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isStatusOpen(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isStatusOpen", "isStatusOpen(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  marketSigners(param0: Address): boolean {
    let result = super.call("marketSigners", "marketSigners(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_marketSigners(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "marketSigners",
      "marketSigners(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  minAuctionDuration(): BigInt {
    let result = super.call(
      "minAuctionDuration",
      "minAuctionDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minAuctionDuration(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minAuctionDuration",
      "minAuctionDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minAuctionIncrement(): BigInt {
    let result = super.call(
      "minAuctionIncrement",
      "minAuctionIncrement():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minAuctionIncrement(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minAuctionIncrement",
      "minAuctionIncrement():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC1155BatchReceived(
    operator: Address,
    from: Address,
    ids: Array<BigInt>,
    values: Array<BigInt>,
    data: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigIntArray(ids),
        ethereum.Value.fromUnsignedBigIntArray(values),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155BatchReceived(
    operator: Address,
    from: Address,
    ids: Array<BigInt>,
    values: Array<BigInt>,
    data: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigIntArray(ids),
        ethereum.Value.fromUnsignedBigIntArray(values),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC1155Received(
    operator: Address,
    from: Address,
    id: BigInt,
    value: BigInt,
    data: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    operator: Address,
    from: Address,
    id: BigInt,
    value: BigInt,
    data: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC721Received(
    operator: Address,
    from: Address,
    tokenId: BigInt,
    data: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(tokenId),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    operator: Address,
    from: Address,
    tokenId: BigInt,
    data: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(tokenId),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  paused(): boolean {
    let result = super.call("paused", "paused():(bool)", []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("paused", "paused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  weth(): Address {
    let result = super.call("weth", "weth():(address)", []);

    return result[0].toAddress();
  }

  try_weth(): ethereum.CallResult<Address> {
    let result = super.tryCall("weth", "weth():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get weth_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class CancelBuysCall extends ethereum.Call {
  get inputs(): CancelBuysCall__Inputs {
    return new CancelBuysCall__Inputs(this);
  }

  get outputs(): CancelBuysCall__Outputs {
    return new CancelBuysCall__Outputs(this);
  }
}

export class CancelBuysCall__Inputs {
  _call: CancelBuysCall;

  constructor(call: CancelBuysCall) {
    this._call = call;
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }
}

export class CancelBuysCall__Outputs {
  _call: CancelBuysCall;

  constructor(call: CancelBuysCall) {
    this._call = call;
  }
}

export class EmergencyCancelAuctionCall extends ethereum.Call {
  get inputs(): EmergencyCancelAuctionCall__Inputs {
    return new EmergencyCancelAuctionCall__Inputs(this);
  }

  get outputs(): EmergencyCancelAuctionCall__Outputs {
    return new EmergencyCancelAuctionCall__Outputs(this);
  }
}

export class EmergencyCancelAuctionCall__Inputs {
  _call: EmergencyCancelAuctionCall;

  constructor(call: EmergencyCancelAuctionCall) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get noBundle(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class EmergencyCancelAuctionCall__Outputs {
  _call: EmergencyCancelAuctionCall;

  constructor(call: EmergencyCancelAuctionCall) {
    this._call = call;
  }
}

export class InCaseMoneyGetsStuckCall extends ethereum.Call {
  get inputs(): InCaseMoneyGetsStuckCall__Inputs {
    return new InCaseMoneyGetsStuckCall__Inputs(this);
  }

  get outputs(): InCaseMoneyGetsStuckCall__Outputs {
    return new InCaseMoneyGetsStuckCall__Outputs(this);
  }
}

export class InCaseMoneyGetsStuckCall__Inputs {
  _call: InCaseMoneyGetsStuckCall;

  constructor(call: InCaseMoneyGetsStuckCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get currency(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class InCaseMoneyGetsStuckCall__Outputs {
  _call: InCaseMoneyGetsStuckCall;

  constructor(call: InCaseMoneyGetsStuckCall) {
    this._call = call;
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RunCall extends ethereum.Call {
  get inputs(): RunCall__Inputs {
    return new RunCall__Inputs(this);
  }

  get outputs(): RunCall__Outputs {
    return new RunCall__Outputs(this);
  }
}

export class RunCall__Inputs {
  _call: RunCall;

  constructor(call: RunCall) {
    this._call = call;
  }

  get intent(): RunCallIntentStruct {
    return changetype<RunCallIntentStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get detail(): RunCallDetailStruct {
    return changetype<RunCallDetailStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }

  get sigIntent(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get sigDetail(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class RunCall__Outputs {
  _call: RunCall;

  constructor(call: RunCall) {
    this._call = call;
  }
}

export class RunCallIntentStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get bundle(): Array<RunCallIntentBundleStruct> {
    return this[1].toTupleArray<RunCallIntentBundleStruct>();
  }

  get currency(): Address {
    return this[2].toAddress();
  }

  get price(): BigInt {
    return this[3].toBigInt();
  }

  get deadline(): BigInt {
    return this[4].toBigInt();
  }

  get salt(): Bytes {
    return this[5].toBytes();
  }

  get kind(): i32 {
    return this[6].toI32();
  }
}

export class RunCallIntentBundleStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }

  get amount(): BigInt {
    return this[2].toBigInt();
  }

  get kind(): i32 {
    return this[3].toI32();
  }

  get mintData(): Bytes {
    return this[4].toBytes();
  }
}

export class RunCallDetailStruct extends ethereum.Tuple {
  get intentionHash(): Bytes {
    return this[0].toBytes();
  }

  get signer(): Address {
    return this[1].toAddress();
  }

  get txDeadline(): BigInt {
    return this[2].toBigInt();
  }

  get salt(): Bytes {
    return this[3].toBytes();
  }

  get id(): BigInt {
    return this[4].toBigInt();
  }

  get opcode(): i32 {
    return this[5].toI32();
  }

  get caller(): Address {
    return this[6].toAddress();
  }

  get currency(): Address {
    return this[7].toAddress();
  }

  get price(): BigInt {
    return this[8].toBigInt();
  }

  get incentiveRate(): BigInt {
    return this[9].toBigInt();
  }

  get settlement(): RunCallDetailSettlementStruct {
    return changetype<RunCallDetailSettlementStruct>(this[10].toTuple());
  }

  get bundle(): Array<RunCallDetailBundleStruct> {
    return this[11].toTupleArray<RunCallDetailBundleStruct>();
  }

  get deadline(): BigInt {
    return this[12].toBigInt();
  }
}

export class RunCallDetailSettlementStruct extends ethereum.Tuple {
  get coupons(): Array<BigInt> {
    return this[0].toBigIntArray();
  }

  get feeRate(): BigInt {
    return this[1].toBigInt();
  }

  get royaltyRate(): BigInt {
    return this[2].toBigInt();
  }

  get buyerCashbackRate(): BigInt {
    return this[3].toBigInt();
  }

  get feeAddress(): Address {
    return this[4].toAddress();
  }

  get royaltyAddress(): Address {
    return this[5].toAddress();
  }
}

export class RunCallDetailBundleStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }

  get amount(): BigInt {
    return this[2].toBigInt();
  }

  get kind(): i32 {
    return this[3].toI32();
  }

  get mintData(): Bytes {
    return this[4].toBytes();
  }
}

export class SendCall extends ethereum.Call {
  get inputs(): SendCall__Inputs {
    return new SendCall__Inputs(this);
  }

  get outputs(): SendCall__Outputs {
    return new SendCall__Outputs(this);
  }
}

export class SendCall__Inputs {
  _call: SendCall;

  constructor(call: SendCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokens(): Array<SendCallTokensStruct> {
    return this._call.inputValues[1].value.toTupleArray<SendCallTokensStruct>();
  }
}

export class SendCall__Outputs {
  _call: SendCall;

  constructor(call: SendCall) {
    this._call = call;
  }
}

export class SendCallTokensStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapCall extends ethereum.Call {
  get inputs(): SwapCall__Inputs {
    return new SwapCall__Inputs(this);
  }

  get outputs(): SwapCall__Outputs {
    return new SwapCall__Outputs(this);
  }
}

export class SwapCall__Inputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get req(): SwapCallReqStruct {
    return changetype<SwapCallReqStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class SwapCall__Outputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }
}

export class SwapCallReqStruct extends ethereum.Tuple {
  get salt(): Bytes {
    return this[0].toBytes();
  }

  get creator(): Address {
    return this[1].toAddress();
  }

  get deadline(): BigInt {
    return this[2].toBigInt();
  }

  get has(): Array<SwapCallReqHasStruct> {
    return this[3].toTupleArray<SwapCallReqHasStruct>();
  }

  get wants(): Array<SwapCallReqWantsStruct> {
    return this[4].toTupleArray<SwapCallReqWantsStruct>();
  }
}

export class SwapCallReqHasStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }
}

export class SwapCallReqWantsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get tokenId(): BigInt {
    return this[1].toBigInt();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UnpauseCall extends ethereum.Call {
  get inputs(): UnpauseCall__Inputs {
    return new UnpauseCall__Inputs(this);
  }

  get outputs(): UnpauseCall__Outputs {
    return new UnpauseCall__Outputs(this);
  }
}

export class UnpauseCall__Inputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnpauseCall__Outputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UpdateSettingsCall extends ethereum.Call {
  get inputs(): UpdateSettingsCall__Inputs {
    return new UpdateSettingsCall__Inputs(this);
  }

  get outputs(): UpdateSettingsCall__Outputs {
    return new UpdateSettingsCall__Outputs(this);
  }
}

export class UpdateSettingsCall__Inputs {
  _call: UpdateSettingsCall;

  constructor(call: UpdateSettingsCall) {
    this._call = call;
  }

  get minAuctionIncrement_(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get minAuctionDuration_(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UpdateSettingsCall__Outputs {
  _call: UpdateSettingsCall;

  constructor(call: UpdateSettingsCall) {
    this._call = call;
  }
}

export class UpdateSignerCall extends ethereum.Call {
  get inputs(): UpdateSignerCall__Inputs {
    return new UpdateSignerCall__Inputs(this);
  }

  get outputs(): UpdateSignerCall__Outputs {
    return new UpdateSignerCall__Outputs(this);
  }
}

export class UpdateSignerCall__Inputs {
  _call: UpdateSignerCall;

  constructor(call: UpdateSignerCall) {
    this._call = call;
  }

  get addr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get remove(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class UpdateSignerCall__Outputs {
  _call: UpdateSignerCall;

  constructor(call: UpdateSignerCall) {
    this._call = call;
  }
}
